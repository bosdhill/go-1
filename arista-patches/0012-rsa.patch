diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 46994344bb..8ea3bac271 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -103,7 +103,7 @@ func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]b
 		}
 		out, err := boring.DecryptRSAPKCS1(bkey, ciphertext)
 		if err != nil {
-			return nil, ErrDecryption
+			return nil, err
 		}
 		return out, nil
 	}
@@ -331,7 +331,7 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)
 			return err
 		}
 		if err := boring.VerifyRSAPKCS1v15(bkey, hash, hashed, sig); err != nil {
-			return ErrVerification
+			return err
 		}
 		return nil
 	}
diff --git a/src/crypto/rsa/pkcs1v15_test.go b/src/crypto/rsa/pkcs1v15_test.go
index 69c509a771..85156e5907 100644
--- a/src/crypto/rsa/pkcs1v15_test.go
+++ b/src/crypto/rsa/pkcs1v15_test.go
@@ -8,7 +8,6 @@ import (
 	"bytes"
 	"crypto"
 	"crypto/rand"
-	"crypto/sha1"
 	"crypto/sha256"
 	"encoding/base64"
 	"encoding/hex"
@@ -18,6 +17,8 @@ import (
 	"testing/quick"
 )
 
+import boring "crypto/internal/backend"
+
 func decodeBase64(in string) []byte {
 	out := make([]byte, base64.StdEncoding.DecodedLen(len(in)))
 	n, err := base64.StdEncoding.Decode(out, []byte(in))
@@ -31,22 +32,22 @@ type DecryptPKCS1v15Test struct {
 	in, out string
 }
 
-// These test vectors were generated with `openssl rsautl -pkcs -encrypt`
+// Test vectors for testRSA2048PrivateKey
 var decryptPKCS1v15Tests = []DecryptPKCS1v15Test{
 	{
-		"gIcUIoVkD6ATMBk/u/nlCZCCWRKdkfjCgFdo35VpRXLduiKXhNz1XupLLzTXAybEq15juc+EgY5o0DHv/nt3yg==",
+		"Ppg5lRhQZ8zLMgU8jFWURwm+Oj3t1+9x8qIDZwWMlP6O1QVO4xXxHdheVnLRa0Iq+L5HTgjk/PNNkSLIMD11ERxbMD5NtXoj64qaQDkyIBXaN0FNc5Nga/Lbb+vXVYSJ5F4KIOUYaOwzgNSCMensYNz5/7TloMy2Zoqa6vsWzcU+ujfyFaNjJXC26ZM0zv/4v9Aqqb/WIsLjEgdVvplqL1jwbI8Vv/MLEpQRay3S2RHoS9PIcvGKe3Ze0nOE8rAPiRQKfAsX+zlMkw1+LDttb5Dg/vM4lGF6jTg/nmfgCb6gjWE+QpapLKuZIN3WOwG/zslKeROErPn71xAlVeHI1Q==",
 		"x",
 	},
 	{
-		"Y7TOCSqofGhkRb+jaVRLzK8xw2cSo1IVES19utzv6hwvx+M8kFsoWQm5DzBeJCZTCVDPkTpavUuEbgp8hnUGDw==",
+		"kjtn1z9R67b0t7RydEoXeK9GC9wWt1J47i+14alOLCuWr9aqnJxYJS+jr2Z3/TWf4qqTiEujIP5bzvM8vnU2cnJqOGUqoH5xH1+8gq9aD0RbVY0auvUxPUKI3foLoMlp6M1fTSJGiuD9DASp7BZfiMvsU1kKPrLlHpu4azOKbAfIojyyt64Dl3cIpha8FBakym1SRM2iJKKBVae3Reu58uGX9lHroJAWiIdDT4VDIGXQv9dvsViPn4hvWKls5xYtf3V5GPHyvrptsLYcqBOUXM1Wnu2SpZxKRuyz9tWA3w377XNByDMchLJeC4qxdA6ayo53ckXr0no0fU0JrRHkdg==",
 		"testing.",
 	},
 	{
-		"arReP9DJtEVyV2Dg3dDp4c/PSk1O6lxkoJ8HcFupoRorBZG+7+1fDAwT1olNddFnQMjmkb8vxwmNMoTAT/BFjQ==",
+		"gljV2jJNON8RwzgVezwG/ddFWPSpGHgnUgEot42vU7Kow5TMvd43f9QAJsPQd0ocT9YIp/3km+2CSWWr+5E3fWW0p2cQBxUfnsJFsNKPvQt6Ct7Bn8HzkhxLJuvIShFzQlBuph4hBuN33dWhAFFDESsZnPvU6EFJlmTHrmqY+H9cdECU4hXQ1R7Z+lHlvT8RxDNBu1fdAarRXcKrw9EeN2ZwSvVx62aXnAcAQQkijmOn9dkObgqeii/wHPI28SR/Aa/hTw1XE5DoZmDBCx6EFJ4hcY7MKAX0iSQiaxinM+IxkqiCftOnvYv737cD/vKG6llhGCCDx0Et5xYu2JWakw==",
 		"testing.\n",
 	},
 	{
-		"WtaBXIoGC54+vH0NH0CHHE+dRDOsMc/6BrfFu2lEqcKL9+uDuWaf+Xj9mrbQCjjZcpQuX733zyok/jsnqe/Ftw==",
+		"iJiYwVBtLhZBmYngT5u+YR5+raI33OvpShPR9arl4zSss+eK5krMANZUTrRCsw8Tho6kpyDgVohfH5V/8zX4Rtslak1peZdvnmcEkJCFk0FpnlcALRBGTCXUJEwxlSgaTz00awCjkfLzMYNCwTAlEP9QxUX2kSIABKSUw4ARwZ5jQTGCdJNl696Q/cF1JjEqsjpPbjn4UYkV3gNl0xXPiTVgfNJKZir1caEGOKfOsfbTFixvA5oANgRySxwZfoj/6dW9xIVgcq/ssmkTl8TnTKQTY0dRTNWs8+HuQxp2I4MSmAun6LYdr8pom1IazJtp1BEaSDZ+thRIQ/oMsYDJXQ==",
 		"01234567890123456789012345678901234567890123456789012",
 	},
 }
@@ -54,10 +55,10 @@ var decryptPKCS1v15Tests = []DecryptPKCS1v15Test{
 func TestDecryptPKCS1v15(t *testing.T) {
 	decryptionFuncs := []func([]byte) ([]byte, error){
 		func(ciphertext []byte) (plaintext []byte, err error) {
-			return DecryptPKCS1v15(nil, rsaPrivateKey, ciphertext)
+			return DecryptPKCS1v15(nil, testRSA2048PrivateKey, ciphertext)
 		},
 		func(ciphertext []byte) (plaintext []byte, err error) {
-			return rsaPrivateKey.Decrypt(nil, ciphertext, nil)
+			return testRSA2048PrivateKey.Decrypt(nil, ciphertext, nil)
 		},
 	}
 
@@ -77,14 +78,14 @@ func TestDecryptPKCS1v15(t *testing.T) {
 
 func TestEncryptPKCS1v15(t *testing.T) {
 	random := rand.Reader
-	k := (rsaPrivateKey.N.BitLen() + 7) / 8
+	k := (testRSA2048PrivateKey.N.BitLen() + 7) / 8
 
 	tryEncryptDecrypt := func(in []byte, blind bool) bool {
 		if len(in) > k-11 {
 			in = in[0 : k-11]
 		}
 
-		ciphertext, err := EncryptPKCS1v15(random, &rsaPrivateKey.PublicKey, in)
+		ciphertext, err := EncryptPKCS1v15(random, &testRSA2048PrivateKey.PublicKey, in)
 		if err != nil {
 			t.Errorf("error encrypting: %s", err)
 			return false
@@ -96,7 +97,7 @@ func TestEncryptPKCS1v15(t *testing.T) {
 		} else {
 			rand = random
 		}
-		plaintext, err := DecryptPKCS1v15(rand, rsaPrivateKey, ciphertext)
+		plaintext, err := DecryptPKCS1v15(rand, testRSA2048PrivateKey, ciphertext)
 		if err != nil {
 			t.Errorf("error decrypting: %s", err)
 			return false
@@ -116,22 +117,22 @@ func TestEncryptPKCS1v15(t *testing.T) {
 	quick.Check(tryEncryptDecrypt, config)
 }
 
-// These test vectors were generated with `openssl rsautl -pkcs -encrypt`
+// Test vectors for testRSA2048PrivateKey
 var decryptPKCS1v15SessionKeyTests = []DecryptPKCS1v15Test{
 	{
-		"e6ukkae6Gykq0fKzYwULpZehX+UPXYzMoB5mHQUDEiclRbOTqas4Y0E6nwns1BBpdvEJcilhl5zsox/6DtGsYg==",
+		"cSBy/rsocfCY2L/WDP7+oyI/uk0qf3BuJvWo1VwV/DG9XLuu7J1Gb2e7hYl3kmdf6rSnoqDuVE3viOsGeq1OsW9w0uw08syTwdOp34z90qxlrrKsGjjz9XIgErqwlWvfQ5KQQb8KA29Ub7q0sqQMMQD75bUxN3P4GhtOG6kNVY33QoCIVR65vHLcqe3SlrxAfYzlOjMNwdPsNP1GGVyAZpccxOiBJSUrssAFvRJ3g62wj2xrrtneRztmOGOy8ZSiEjGNjJ4/lmJXt2GyPXapTTKeHFbyqh5Xu8PNgMxaCgtWgMqnK6CPbJOGgski9axyaxPzjKEjUcs99dJ1mTT+qw==",
 		"1234",
 	},
 	{
-		"Dtis4uk/q/LQGGqGk97P59K03hkCIVFMEFZRgVWOAAhxgYpCRG0MX2adptt92l67IqMki6iVQyyt0TtX3IdtEw==",
+		"lcsS8tzZSJSiaaOSQSO4pT3Je5vvrNfAVUy3Axojr4uRreMuLRTIOOmEYRM/JcWakpJelPd+EHG/aXxId8aCoBg1MkH5q8AHW3zUARhlOd91rpASVs03v5wuk0jtiQiqr0HLNyxifSEzj04VPklc6n00yuHbI+DNTATTVkxj3a5hgOECqKi2matXGcJ5FtMEPAi2V+36y2dQ+DA/tgQrhlZ4ycA2FJnjvOHRJbC6QwNzPkzbjTlCqNzq92nwWKDypVJ29CrIQ2HYXG63DOuT96gIa08hyeZEeIrAUjtb9DK1TSEF/9BDASffHevW3/CqfpRYnFSNOj2xli3wBn1Dvg==",
 		"FAIL",
 	},
 	{
-		"LIyFyCYCptPxrvTxpol8F3M7ZivlMsf53zs0vHRAv+rDIh2YsHS69ePMoPMe3TkOMZ3NupiL3takPxIs1sK+dw==",
+		"Bsrz5yYuevhqx1Pxx4zEsegU2aVBZ2h9ebtAgQkq3N/og0t+8O92XpPBoNH/HT2jHclh01aij1niCqdBn2/6GBN4irnVjrWQkoAV2Q5Q+gVS0ZYeTzeX/15M/iq9xeLjBPXqj5PmNYh+vbL05FyPB+CcY8MPyv7HmtDsAWRVDxQVWy6y4lmC1/VwnG5jtmAbapE+Vyty0iVb9/Q6UaaV7DVKVssEDmwnychibJ4ACcTQ18kLkB1AE73dXp1B/XHh6ExbHXoaPeaRYr2gEI0No6VBTrMrG5eVz3dub/a5MVeat9n/oU2QQ3s/Pm0FlF9n2mwgvKm/4nLjwjiTFt3ToQ==",
 		"abcd",
 	},
 	{
-		"bafnobel46bKy76JzqU/RIVOH0uAYvzUtauKmIidKgM0sMlvobYVAVQPeUQ/oTGjbIZ1v/6Gyi5AO4DtHruGdw==",
+		"FKynVeuuoYxonMoXWwIw3mY7KTV3yS3fe2D+h5v6FXs/0xb5PeINCEq0+Ub5LFAZcx/lIbnt4bkLZcaKDxLpBCxpvpZNdgGxP970BvE5xmOuagF47VaqCciiERTTztRjwKTu0PZ5VtcpsxiSN4axlC1NOpJnIpDsNOWUaf5G6fCCEdfZWwgxaHLbxSAy+IdUHBH+honCPPZAyGyhERdcDRGJ8a6R20MFXC18e8asHtF5VWaicaYe0fy1Mrii46WqFY8hwoSrbHOGEQkjRymM/IQvXFdxQ1vtzAFavUsr5taiVe84DvcFJ5eRZ2jpVQTdO4gBy6RyD64iNSrv8a5dqA==",
 		"FAIL",
 	},
 }
@@ -139,7 +140,7 @@ var decryptPKCS1v15SessionKeyTests = []DecryptPKCS1v15Test{
 func TestEncryptPKCS1v15SessionKey(t *testing.T) {
 	for i, test := range decryptPKCS1v15SessionKeyTests {
 		key := []byte("FAIL")
-		err := DecryptPKCS1v15SessionKey(nil, rsaPrivateKey, decodeBase64(test.in), key)
+		err := DecryptPKCS1v15SessionKey(nil, testRSA2048PrivateKey, decodeBase64(test.in), key)
 		if err != nil {
 			t.Errorf("#%d error decrypting", i)
 		}
@@ -152,7 +153,7 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {
 
 func TestEncryptPKCS1v15DecrypterSessionKey(t *testing.T) {
 	for i, test := range decryptPKCS1v15SessionKeyTests {
-		plaintext, err := rsaPrivateKey.Decrypt(rand.Reader, decodeBase64(test.in), &PKCS1v15DecryptOptions{SessionKeyLen: 4})
+		plaintext, err := testRSA2048PrivateKey.Decrypt(rand.Reader, decodeBase64(test.in), &PKCS1v15DecryptOptions{SessionKeyLen: 4})
 		if err != nil {
 			t.Fatalf("#%d: error decrypting: %s", i, err)
 		}
@@ -186,20 +187,19 @@ type signPKCS1v15Test struct {
 	in, out string
 }
 
-// These vectors have been tested with
-//
-//	`openssl rsautl -verify -inkey pk -in signature | hexdump -C`
-var signPKCS1v15Tests = []signPKCS1v15Test{
-	{"Test.\n", "a4f3fa6ea93bcdd0c57be020c1193ecbfd6f200a3d95c409769b029578fa0e336ad9a347600e40d3ae823b8c7e6bad88cc07c1d54c3a1523cbbb6d58efc362ae"},
+// Test vector for testRSA2048PrivateKey
+// generated with `openssl pkeyutl -rawin -digest sha256 -sign -inkey <key>`
+ var signPKCS1v15Tests = []signPKCS1v15Test{
+	{"Test.\n", "467c3c8f16223ba09aecfe44488d6b34b3f91f11379949b1d8af31636ee8b3aa51eebb96ee11678323cb1f909af17c9d0fe4b6012078af8120474474efd1bb51765e1647369ddba6525c6608113857bb0e2aaed9ad01fe041b476b162f7d4db55bb31fa957046616ce463cecb2a66f38fa62c594d07afcc870582d545853b31fa705ab8565e4085804c32e73459720bf4e08f097843b0845116d4376231fa2472abc89b1e42462002bf70f9a1df31db6d2ab6dc52c8223798a4f57c40d6a9123b80739846d779044eac28d8c783e8ce73919f1d4a6efe8fb601b8d36c5c9b61654d6f8717d1fb9fcafa19669200900899dd08ce921a1745312eb06040a405903"},
 }
 
 func TestSignPKCS1v15(t *testing.T) {
 	for i, test := range signPKCS1v15Tests {
-		h := sha1.New()
+		h := sha256.New()
 		h.Write([]byte(test.in))
 		digest := h.Sum(nil)
 
-		s, err := SignPKCS1v15(nil, rsaPrivateKey, crypto.SHA1, digest)
+		s, err := SignPKCS1v15(nil, testRSA2048PrivateKey, crypto.SHA256, digest)
 		if err != nil {
 			t.Errorf("#%d %s", i, err)
 		}
@@ -213,13 +213,13 @@ func TestSignPKCS1v15(t *testing.T) {
 
 func TestVerifyPKCS1v15(t *testing.T) {
 	for i, test := range signPKCS1v15Tests {
-		h := sha1.New()
+		h := sha256.New()
 		h.Write([]byte(test.in))
 		digest := h.Sum(nil)
 
 		sig, _ := hex.DecodeString(test.out)
 
-		err := VerifyPKCS1v15(&rsaPrivateKey.PublicKey, crypto.SHA1, digest, sig)
+		err := VerifyPKCS1v15(&testRSA2048PrivateKey.PublicKey, crypto.SHA256, digest, sig)
 		if err != nil {
 			t.Errorf("#%d %s", i, err)
 		}
@@ -235,6 +235,9 @@ func TestOverlongMessagePKCS1v15(t *testing.T) {
 }
 
 func TestUnpaddedSignature(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("skipping in boring mode")
+	}
 	msg := []byte("Thu Dec 19 18:06:16 EST 2013\n")
 	// This base64 value was generated with:
 	// % echo Thu Dec 19 18:06:16 EST 2013 > /tmp/msg
@@ -259,13 +262,13 @@ func TestUnpaddedSignature(t *testing.T) {
 func TestShortSessionKey(t *testing.T) {
 	// This tests that attempting to decrypt a session key where the
 	// ciphertext is too small doesn't run outside the array bounds.
-	ciphertext, err := EncryptPKCS1v15(rand.Reader, &rsaPrivateKey.PublicKey, []byte{1})
+	ciphertext, err := EncryptPKCS1v15(rand.Reader, &testRSA2048PrivateKey.PublicKey, []byte{1})
 	if err != nil {
 		t.Fatalf("Failed to encrypt short message: %s", err)
 	}
 
 	var key [32]byte
-	if err := DecryptPKCS1v15SessionKey(nil, rsaPrivateKey, ciphertext, key[:]); err != nil {
+	if err := DecryptPKCS1v15SessionKey(nil, testRSA2048PrivateKey, ciphertext, key[:]); err != nil {
 		t.Fatalf("Failed to decrypt short message: %s", err)
 	}
 
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index 51f9760187..ec4bb4ecc1 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -20,6 +20,8 @@ import (
 	"testing"
 )
 
+import boring "crypto/internal/backend"
+
 func TestEMSAPSS(t *testing.T) {
 	// Test vector in file pss-int.txt from: ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip
 	msg := []byte{
@@ -168,22 +170,18 @@ func TestPSSGolden(t *testing.T) {
 // the default options. OpenSSL sets the salt length to be maximal.
 func TestPSSOpenSSL(t *testing.T) {
 	hash := crypto.SHA256
+	hashed := []byte("testing")
 	h := hash.New()
-	h.Write([]byte("testing"))
-	hashed := h.Sum(nil)
+	h.Write(hashed)
+	hashed = h.Sum(nil)
 
+	// Test vector for testRSA2048PrivateKey
 	// Generated with `echo -n testing | openssl dgst -sign key.pem -sigopt rsa_padding_mode:pss -sha256 > sig`
 	sig := []byte{
-		0x95, 0x59, 0x6f, 0xd3, 0x10, 0xa2, 0xe7, 0xa2, 0x92, 0x9d,
-		0x4a, 0x07, 0x2e, 0x2b, 0x27, 0xcc, 0x06, 0xc2, 0x87, 0x2c,
-		0x52, 0xf0, 0x4a, 0xcc, 0x05, 0x94, 0xf2, 0xc3, 0x2e, 0x20,
-		0xd7, 0x3e, 0x66, 0x62, 0xb5, 0x95, 0x2b, 0xa3, 0x93, 0x9a,
-		0x66, 0x64, 0x25, 0xe0, 0x74, 0x66, 0x8c, 0x3e, 0x92, 0xeb,
-		0xc6, 0xe6, 0xc0, 0x44, 0xf3, 0xb4, 0xb4, 0x2e, 0x8c, 0x66,
-		0x0a, 0x37, 0x9c, 0x69,
+		0x50, 0x97, 0xc1, 0xe2, 0x7c, 0x67, 0x99, 0x50, 0xdc, 0x5a, 0x43, 0xc6, 0xc6, 0xf2, 0xf1, 0xff, 0xcd, 0xe7, 0x66, 0xef, 0x61, 0x41, 0x5f, 0x49, 0x4f, 0xf0, 0x11, 0xfc, 0x3d, 0xa8, 0xf9, 0x3c, 0x3a, 0x8a, 0x71, 0x5c, 0xfa, 0xbc, 0x48, 0x73, 0x37, 0xec, 0x68, 0x6d, 0x6c, 0xca, 0xe, 0x30, 0x74, 0xe1, 0xbd, 0x88, 0xb6, 0x42, 0x92, 0x8d, 0x41, 0x5f, 0x7, 0x80, 0xc5, 0xef, 0xa3, 0x2e, 0x68, 0x47, 0x83, 0xb4, 0x96, 0x4c, 0x53, 0x61, 0x2c, 0xe8, 0xb8, 0x3, 0xae, 0x44, 0x5e, 0xb3, 0x44, 0x10, 0x58, 0xfd, 0x68, 0x9c, 0x33, 0xac, 0x63, 0xfe, 0x9d, 0x84, 0xab, 0x45, 0x70, 0x54, 0xc5, 0x90, 0x1e, 0x80, 0xd4, 0x31, 0x16, 0x15, 0x4b, 0x60, 0x13, 0x24, 0xa, 0xa8, 0xbc, 0xe5, 0xeb, 0xf8, 0x7d, 0x32, 0xd9, 0xcd, 0x8b, 0xef, 0x55, 0x60, 0x1, 0xa6, 0x99, 0xa2, 0xde, 0xb0, 0x68, 0xc1, 0x64, 0x8b, 0x6, 0xe6, 0x75, 0xcf, 0x2d, 0x7a, 0x8b, 0xd6, 0xa3, 0x99, 0xf1, 0xc9, 0xaf, 0x9a, 0x81, 0xe4, 0xac, 0x2e, 0x17, 0x8c, 0x49, 0xfc, 0x12, 0x79, 0xfb, 0x4a, 0xba, 0x68, 0xd8, 0xdb, 0x43, 0x6c, 0x15, 0xaf, 0xa4, 0x16, 0x2f, 0xc9, 0x1e, 0xbe, 0xef, 0xb3, 0x35, 0x14, 0x2f, 0x35, 0x41, 0x10, 0xf8, 0x32, 0xf8, 0x0, 0x5c, 0xbf, 0x77, 0xa, 0xbb, 0x77, 0x49, 0x47, 0x54, 0x7a, 0x58, 0xfd, 0xb3, 0x2c, 0x46, 0xa0, 0x5c, 0x3, 0x7a, 0xf7, 0xab, 0x77, 0xdb, 0xca, 0x9a, 0x38, 0x89, 0xb, 0x3e, 0xb0, 0x13, 0xe8, 0x16, 0xc0, 0xca, 0x29, 0xbb, 0x4a, 0x97, 0x46, 0x53, 0x59, 0x66, 0x81, 0x84, 0x6d, 0xe5, 0xda, 0x26, 0xc9, 0x83, 0xfc, 0x67, 0xd0, 0x96, 0x72, 0x81, 0x1c, 0xe0, 0x4, 0xb7, 0x0, 0xca, 0xe0, 0x4a, 0x51, 0x4e, 0x83, 0xc8, 0xeb, 0xf7, 0x6d,
 	}
 
-	if err := VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, nil); err != nil {
+	if err := VerifyPSS(&testRSA2048PrivateKey.PublicKey, hash, hashed, sig, nil); err != nil {
 		t.Error(err)
 	}
 }
@@ -210,22 +208,26 @@ func TestPSSSigning(t *testing.T) {
 		{8, 8, true},
 	}
 
+	var opts PSSOptions
 	hash := crypto.SHA1
+	key := rsaPrivateKey
+	if boring.Enabled {
+		hash = crypto.SHA256
+		key = testRSA2048PrivateKey
+	}
 	h := hash.New()
 	h.Write([]byte("testing"))
 	hashed := h.Sum(nil)
-	var opts PSSOptions
-
 	for i, test := range saltLengthCombinations {
 		opts.SaltLength = test.signSaltLength
-		sig, err := SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, &opts)
+		sig, err := SignPSS(rand.Reader, key, hash, hashed, &opts)
 		if err != nil {
-			t.Errorf("#%d: error while signing: %s", i, err)
+			t.Errorf("#%d: ALG: %v, error while signing: %s", i, hash, err)
 			continue
 		}
 
 		opts.SaltLength = test.verifySaltLength
-		err = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)
+		err = VerifyPSS(&key.PublicKey, hash, hashed, sig, &opts)
 		if (err == nil) != test.good {
 			t.Errorf("#%d: bad result, wanted: %t, got: %s", i, test.good, err)
 		}
@@ -233,6 +235,9 @@ func TestPSSSigning(t *testing.T) {
 }
 
 func TestSignWithPSSSaltLengthAuto(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("skipping in boring mode: invalid key length")
+	}
 	key, err := GenerateKey(rand.Reader, 513)
 	if err != nil {
 		t.Fatal(err)
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 6fd49b9106..6712f23e83 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -35,34 +35,42 @@ func TestKeyGeneration(t *testing.T) {
 }
 
 func Test3PrimeKeyGeneration(t *testing.T) {
-	size := 768
+	var sizes []int
 	if testing.Short() {
-		size = 256
+		sizes = []int{256}
+	} else {
+		sizes = []int{128, 768, 1024, 2048, 3072}
 	}
+	for _, size := range sizes {
 
-	priv, err := GenerateMultiPrimeKey(rand.Reader, 3, size)
-	if err != nil {
-		t.Errorf("failed to generate key")
+		priv, err := GenerateMultiPrimeKey(rand.Reader, 3, size)
+		if err != nil {
+			t.Errorf("failed to generate key")
+		}
+		testKeyBasics(t, priv)
 	}
-	testKeyBasics(t, priv)
 }
 
 func Test4PrimeKeyGeneration(t *testing.T) {
-	size := 768
+	var sizes []int
 	if testing.Short() {
-		size = 256
+		sizes = []int{256}
+	} else {
+		sizes = []int{128, 768, 1024, 2048, 3072}
 	}
+	for _, size := range sizes {
 
-	priv, err := GenerateMultiPrimeKey(rand.Reader, 4, size)
-	if err != nil {
-		t.Errorf("failed to generate key")
+		priv, err := GenerateMultiPrimeKey(rand.Reader, 4, size)
+		if err != nil {
+			t.Errorf("failed to generate key")
+		}
+		testKeyBasics(t, priv)
 	}
-	testKeyBasics(t, priv)
 }
 
 func TestNPrimeKeyGeneration(t *testing.T) {
 	primeSize := 64
-	maxN := 24
+	maxN := 32
 	if testing.Short() {
 		primeSize = 16
 		maxN = 16
@@ -121,18 +129,22 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 		}
 		// Cannot call encrypt/decrypt directly. Test via PKCS1v15.
 		msg := []byte("hi!")
-		enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
-		if err != nil {
-			t.Errorf("EncryptPKCS1v15: %v", err)
-			return
-		}
-		dec, err := DecryptPKCS1v15(rand.Reader, priv, enc)
-		if err != nil {
-			t.Errorf("DecryptPKCS1v15: %v", err)
-			return
-		}
-		if !bytes.Equal(dec, msg) {
-			t.Errorf("got:%x want:%x (%+v)", dec, msg, priv)
+		if priv.Size() >= 256 {
+			enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
+			if err != nil {
+				t.Errorf("EncryptPKCS1v15: %v", err)
+				return
+			}
+			dec, err := DecryptPKCS1v15(rand.Reader, priv, enc)
+			if err != nil {
+				t.Errorf("DecryptPKCS1v15: %v", err)
+				return
+			}
+			if !bytes.Equal(dec, msg) {
+				t.Errorf("got:%x want:%x (%+v)", dec, msg, priv)
+			}
+		} else {
+			t.Logf("skipping check for unsupported key less than 2048 bits")
 		}
 		return
 	}
@@ -168,6 +180,7 @@ func fromBase10(base10 string) *big.Int {
 }
 
 var test2048Key *PrivateKey
+var testRSA2048PrivateKey *PrivateKey
 
 func init() {
 	test2048Key = &PrivateKey{
@@ -182,6 +195,21 @@ func init() {
 		},
 	}
 	test2048Key.Precompute()
+	// This is the same testRSA2048PrivateKey from src/crypto/tls/boring_test.go,
+	// just formatted without using the x509 Parser
+	testRSA2048PrivateKey = &PrivateKey {
+		PublicKey: PublicKey{
+                        N: fromBase10("20191212046465051006148469115982609963794084216822290493008497548603282433337961188011759317867632936762484431807200684727542982286641865915343951546098189846608892055894575224375729344858650310374442622904229900868894242623139807621975608166515302294530216022389036816474348374698399654955992710180316983674809047409565569027596663420090767109285120403886497729233127551307356270679924351259776100107640885071765865832767303853854517356000385050677175012549806941229051812974721510192346810990827150439838227830352248569839727388943852973737249863837089274675024496841834194785931485429238306703429257731792443735979"),
+                        E: 65537,
+                },
+                D: fromBase10("17880854551669112566868255345124108779447961606053558991611260520405836487267781427740459393783689829925402008838157275130340717548134956040019107677074732476577915942750039777107871579671122369249613210066309031335411813988461299033587444447689322284662780986426216011635232478916424602504476935371549462113036228740820951710434375466081011497256196435741125837599218374223248197677547321257961509961401385322723627033844333644253777689603896264679633990939957571483400832267925506777396569554295752505112186882586887396943424085633026984063372469902814987050483471096892524886948283571883744403645335501920852525393"),
+                Primes: []*big.Int{
+                        fromBase10("135564917074042739008372452399559667250812269638554028593490636590148234941034106656615266472037321030780472224077878987192393666277731486488609490961161995141171813440923127505183021899359310251888145112092740773465142711876177808655062479870526201006500762429604105802612357839979630776094264195301632424911"),
+                        fromBase10("148941278335581696308445609123523329975323575697232717856977715718810138995490768513650108277383732380774181214791356462453504708304090734692215322335879527529217737837271384209093576836051031684425884921572908683147368296418243939771852059523598364231128661438022752350148969064661946939745752818523498309989"),
+                },
+	}
+	testRSA2048PrivateKey.Precompute()
+
 }
 
 func BenchmarkRSA2048Decrypt(b *testing.B) {
@@ -253,6 +281,9 @@ type testEncryptOAEPStruct struct {
 }
 
 func TestEncryptOAEP(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("skip test, it's using internal seeded random")
+	}
 	sha1 := sha1.New()
 	n := new(big.Int)
 	for i, test := range testEncryptOAEPData {
@@ -318,6 +349,11 @@ func TestEncryptDecryptOAEP(t *testing.T) {
 		priv.PublicKey = PublicKey{N: n, E: test.e}
 		priv.D = d
 
+		if boring.Enabled && priv.PublicKey.Size() < 256 {
+			t.Logf("skipping check for unsupported key less than 2048 bits")
+			continue;
+		}
+		t.Logf("running check for supported key size")
 		for j, message := range test.msgs {
 			label := []byte(fmt.Sprintf("hi#%d", j))
 			enc, err := EncryptOAEP(sha256, rand.Reader, &priv.PublicKey, message.in, label)
